stages:
  - search
  - fetch_resources
  - consolidate

variables:
  INSTANCE_NAME: "${INSTANCE_NAME}"  # Input: instance name to search for

# Before each job, create temp directories for logs and data
before_script:
  - mkdir -p /tmp/output

# Search for instances in all namespaces and services for EDCR PROD ACTIVE
search_edcr_prod:
  stage: search
  parallel:
    matrix:
      - SERVICE: "cache-prod"
      - SERVICE: "cache-prod-local-mode"
      - SERVICE: "cache-utility"
      - SERVICE: "tp2-cache-prod-a"
      - SERVICE: "tp2-cache-prod-b"
  script:
    - echo "Searching for instance $INSTANCE_NAME in namespace $SERVICE..."
    - export NAMESPACE=$SERVICE
    - NAMESPACE_FOUND=$(kubectl get pods --namespace $NAMESPACE -o wide | grep "$INSTANCE_NAME")
    - if [ -n "$NAMESPACE_FOUND" ]; then
        echo "Instance found in namespace $NAMESPACE";
        echo "$NAMESPACE, $INSTANCE_NAME" >> /tmp/output/edcr_instances.txt;
      else
        echo "Instance not found in namespace $NAMESPACE";
      fi;
  tags:
    - cache-utility-edcr
    - cache-edcr-local-mode
    - tp2-edcr-prod-a
    - tp2-edcr-prod-b

# Search for instances in all namespaces and services for EDCO TEST
search_edco_test:
  stage: search
  parallel:
    matrix:
      - SERVICE: "cache-prep-local-mode"
      - SERVICE: "cache-prep"
      - SERVICE: "cache-test"
      - SERVICE: "tp2-edco-cache-test-b"
      - SERVICE: "tp2-edco-cache-test-c"
  script:
    - echo "Searching for instance $INSTANCE_NAME in namespace $SERVICE..."
    - export NAMESPACE=$SERVICE
    - NAMESPACE_FOUND=$(kubectl get pods --namespace $NAMESPACE -o wide | grep "$INSTANCE_NAME")
    - if [ -n "$NAMESPACE_FOUND" ]; then
        echo "Instance found in namespace $NAMESPACE";
        echo "$NAMESPACE, $INSTANCE_NAME" >> /tmp/output/edco_test_instances.txt;
      else
        echo "Instance not found in namespace $NAMESPACE";
      fi;
  tags:
    - cache-utility-test
    - cache-test-local-mode
    - tp2-edco-cache-test-b
    - tp2-edco-cache-test-c

# Fetch resource data from EDCR PROD ACTIVE namespaces
fetch_resources_edcr:
  stage: fetch_resources
  needs: ["search_edcr_prod"]
  parallel:
    matrix:
      - SERVICE: "cache-prod"
      - SERVICE: "cache-prod-local-mode"
      - SERVICE: "tp2-cache-prod-a"
      - SERVICE: "tp2-cache-prod-b"
  script:
    - |
      fetch_resource_data() {
        NAMESPACE=$SERVICE
        export NAMESPACE
        STS_NAME=$(kubectl get statefulsets --namespace $NAMESPACE | grep "$INSTANCE_NAME" | awk '{print $1}')
        if [ -n "$STS_NAME" ]; then
          echo "Fetching resources for $STS_NAME in namespace $NAMESPACE..."
          kubectl get statefulset $STS_NAME --namespace $NAMESPACE -o json | jq '.spec.template.spec.containers[] | {resources}' > /tmp/output/resources_$NAMESPACE.json
        fi
      }
      fetch_resource_data
  tags:
    - cache-utility-edcr
    - cache-edcr-local-mode
    - tp2-edcr-prod-a
    - tp2-edcr-prod-b

# Fetch resource data from EDCO TEST namespaces
fetch_resources_edco:
  stage: fetch_resources
  needs: ["search_edco_test"]
  parallel:
    matrix:
      - SERVICE: "cache-prep"
      - SERVICE: "cache-test"
      - SERVICE: "tp2-edco-cache-test-b"
      - SERVICE: "tp2-edco-cache-test-c"
  script:
    - |
      fetch_resource_data() {
        NAMESPACE=$SERVICE
        export NAMESPACE
        STS_NAME=$(kubectl get statefulsets --namespace $NAMESPACE | grep "$INSTANCE_NAME" | awk '{print $1}')
        if [ -n "$STS_NAME" ]; then
          echo "Fetching resources for $STS_NAME in namespace $NAMESPACE..."
          kubectl get statefulset $STS_NAME --namespace $NAMESPACE -o json | jq '.spec.template.spec.containers[] | {resources}' > /tmp/output/resources_$NAMESPACE.json
        fi
      }
      fetch_resource_data
  tags:
    - cache-utility-test
    - tp2-edco-cache-test-b
    - tp2-edco-cache-test-c

# Consolidate results from EDCR and EDCO
consolidate_report:
  stage: consolidate
  needs: ["fetch_resources_edcr", "fetch_resources_edco"]
  script:
    - echo "Consolidating all resource details..."
    - jq -s 'reduce .[] as $item ({}; . * $item)' /tmp/output/resources_*.json > /tmp/output/final_report.json
    - cat /tmp/output/final_report.json  # Display the final report
  artifacts:
    paths:
      - /tmp/output/final_report.json
  tags:
    - cache-utility-edcr
    - cache-utility-test
