stages:
  - search
  - fetch_resources
  - consolidate

variables:
  INSTANCE_NAME: "${INSTANCE_NAME}"  # Input: instance name to search for

# Before each job, create temp directories for logs and data
before_script:
  - mkdir -p /tmp/output

# Search for instances in all namespaces and services for EDCR PROD ACTIVE
search_edcr_prod:
  stage: search
  parallel:
    matrix:
      - SERVICE: "cache-prod"
      - SERVICE: "cache-prod-local-mode"
      - SERVICE: "cache-utility"
      - SERVICE: "tp2-cache-prod-a"
      - SERVICE: "tp2-cache-prod-b"
  script:
    - echo "Searching for instance $INSTANCE_NAME in namespace $SERVICE..."
    - export NAMESPACE=$SERVICE
    - NAMESPACE_FOUND=$(kubectl get pods --namespace $NAMESPACE -o wide | grep "$INSTANCE_NAME")
    - if [ -n "$NAMESPACE_FOUND" ]; then
        echo "Instance found in namespace $NAMESPACE";
        echo "$NAMESPACE, $INSTANCE_NAME" >> /tmp/output/edcr_instances.txt;
      else
        echo "Instance not found in namespace $NAMESPACE";
      fi;
  tags:
    - cache-utility-edcr
    - cache-edcr-local-mode
    - tp2-edcr-prod-a
    - tp2-edcr-prod-b

# Search for instances in all namespaces and services for EDCO TEST
search_edco_test:
  stage: search
  parallel:
    matrix:
      - SERVICE: "cache-prep-local-mode"
      - SERVICE: "cache-prep"
      - SERVICE: "cache-test"
      - SERVICE: "tp2-edco-cache-test-b"
      - SERVICE: "tp2-edco-cache-test-c"
  script:
    - echo "Searching for instance $INSTANCE_NAME in namespace $SERVICE..."
    - export NAMESPACE=$SERVICE
    - NAMESPACE_FOUND=$(kubectl get pods --namespace $NAMESPACE -o wide | grep "$INSTANCE_NAME")
    - if [ -n "$NAMESPACE_FOUND" ]; then
        echo "Instance found in namespace $NAMESPACE";
        echo "$NAMESPACE, $INSTANCE_NAME" >> /tmp/output/edco_test_instances.txt;
      else
        echo "Instance not found in namespace $NAMESPACE";
      fi;
  tags:
    - cache-utility-test
    - cache-test-local-mode
    - tp2-edco-cache-test-b
    - tp2-edco-cache-test-c

# Fetch resource data from EDCR PROD ACTIVE namespaces
fetch_resources_edcr:
  stage: fetch_resources
  needs: ["search_edcr_prod"]
  parallel:
    matrix:
      - SERVICE: "cache-prod"
      - SERVICE: "cache-prod-local-mode"
      - SERVICE: "tp2-cache-prod-a"
      - SERVICE: "tp2-cache-prod-b"
  script:
    - |
      fetch_resource_data() {
        NAMESPACE=$SERVICE
        export NAMESPACE
        STS_NAME=$(kubectl get statefulsets --namespace $NAMESPACE | grep "$INSTANCE_NAME" | awk '{print $1}')
        if [ -n "$STS_NAME" ]; then
          echo "Fetching resources for $STS_NAME in namespace $NAMESPACE..."
          kubectl get statefulset $STS_NAME --namespace $NAMESPACE -o json | jq '.spec.template.spec.containers[] | {resources}' > /tmp/output/resources_$NAMESPACE.json
        fi
      }
      fetch_resource_data
  tags:
    - cache-utility-edcr
    - cache-edcr-local-mode
    - tp2-edcr-prod-a
    - tp2-edcr-prod-b

# Fetch resource data from EDCO TEST namespaces
fetch_resources_edco:
  stage: fetch_resources
  needs: ["search_edco_test"]
  parallel:
    matrix:
      - SERVICE: "cache-prep"
      - SERVICE: "cache-test"
      - SERVICE: "tp2-edco-cache-test-b"
      - SERVICE: "tp2-edco-cache-test-c"
  script:
    - |
      fetch_resource_data() {
        NAMESPACE=$SERVICE
        export NAMESPACE
        STS_NAME=$(kubectl get statefulsets --namespace $NAMESPACE | grep "$INSTANCE_NAME" | awk '{print $1}')
        if [ -n "$STS_NAME" ]; then
          echo "Fetching resources for $STS_NAME in namespace $NAMESPACE..."
          kubectl get statefulset $STS_NAME --namespace $NAMESPACE -o json | jq '.spec.template.spec.containers[] | {resources}' > /tmp/output/resources_$NAMESPACE.json
        fi
      }
      fetch_resource_data
  tags:
    - cache-utility-test
    - tp2-edco-cache-test-b
    - tp2-edco-cache-test-c

# Consolidate results from EDCR and EDCO
consolidate_report:
  stage: consolidate
  needs: ["fetch_resources_edcr", "fetch_resources_edco"]
  script:
    - echo "Consolidating all resource details..."
    - jq -s 'reduce .[] as $item ({}; . * $item)' /tmp/output/resources_*.json > /tmp/output/final_report.json
    - cat /tmp/output/final_report.json  # Display the final report
  artifacts:
    paths:
      - /tmp/output/final_report.json
  tags:
    - cache-utility-edcr
    - cache-utility-test






















   stages:
  - ping-instances
  - consolidate-results

# Define jobs to ping pods in each namespace using their respective runners in parallel
ping_cache_prod:
  stage: ping-instances
  script:
    - echo "Pinging pods in cache-prod namespace with runner cache-utility-edcr"
    - kubectl get pods -n cache-prod -o jsonpath='{.items[*].status.podIP}' | tr ' ' '\n' > pod_ips_cache_prod.txt
    - touch PING_RESULTS_CACHE_PROD.txt
    - |
      for pod in $(cat pod_ips_cache_prod.txt); do
        (
          PING=$(timeout 5 sh -c '(echo ping; sleep 1) | nc -q 1 -v $pod 6379 2>&1');
          if [ $? -eq 124 ]; then
            echo "cache-prod $pod STS is Down" >> PING_RESULTS_CACHE_PROD.txt;
          elif echo "$PING" | grep -q "+PONG"; then
            echo "cache-prod $pod +PONG" >> PING_RESULTS_CACHE_PROD.txt;
          else
            echo "cache-prod $pod Connection failed: $PING" >> PING_RESULTS_CACHE_PROD.txt;
          fi
        ) &
      done
    - wait
  tags:
    - cache-utility-edcr
  artifacts:
    paths:
      - PING_RESULTS_CACHE_PROD.txt

ping_tp2_cache_prod_a:
  stage: ping-instances
  script:
    - echo "Pinging pods in tp2-cache-prod-a namespace with runner tp2-edcr-prod-a"
    - kubectl get pods -n tp2-cache-prod-a -o jsonpath='{.items[*].status.podIP}' | tr ' ' '\n' > pod_ips_tp2_cache_prod_a.txt
    - touch PING_RESULTS_TP2_CACHE_PROD_A.txt
    - |
      for pod in $(cat pod_ips_tp2_cache_prod_a.txt); do
        (
          PING=$(timeout 5 sh -c '(echo ping; sleep 1) | nc -q 1 -v $pod 6379 2>&1');
          if [ $? -eq 124 ]; then
            echo "tp2-cache-prod-a $pod STS is Down" >> PING_RESULTS_TP2_CACHE_PROD_A.txt;
          elif echo "$PING" | grep -q "+PONG"; then
            echo "tp2-cache-prod-a $pod +PONG" >> PING_RESULTS_TP2_CACHE_PROD_A.txt;
          else
            echo "tp2-cache-prod-a $pod Connection failed: $PING" >> PING_RESULTS_TP2_CACHE_PROD_A.txt;
          fi
        ) &
      done
    - wait
  tags:
    - tp2-edcr-prod-a
  artifacts:
    paths:
      - PING_RESULTS_TP2_CACHE_PROD_A.txt

ping_tp2_cache_prod_b:
  stage: ping-instances
  script:
    - echo "Pinging pods in tp2-cache-prod-b namespace with runner tp2-edcr-prod-b"
    - kubectl get pods -n tp2-cache-prod-b -o jsonpath='{.items[*].status.podIP}' | tr ' ' '\n' > pod_ips_tp2_cache_prod_b.txt
    - touch PING_RESULTS_TP2_CACHE_PROD_B.txt
    - |
      for pod in $(cat pod_ips_tp2_cache_prod_b.txt); do
        (
          PING=$(timeout 5 sh -c '(echo ping; sleep 1) | nc -q 1 -v $pod 6379 2>&1');
          if [ $? -eq 124 ]; then
            echo "tp2-cache-prod-b $pod STS is Down" >> PING_RESULTS_TP2_CACHE_PROD_B.txt;
          elif echo "$PING" | grep -q "+PONG"; then
            echo "tp2-cache-prod-b $pod +PONG" >> PING_RESULTS_TP2_CACHE_PROD_B.txt;
          else
            echo "tp2-cache-prod-b $pod Connection failed: $PING" >> PING_RESULTS_TP2_CACHE_PROD_B.txt;
          fi
        ) &
      done
    - wait
  tags:
    - tp2-edcr-prod-b
  artifacts:
    paths:
      - PING_RESULTS_TP2_CACHE_PROD_B.txt

# Consolidate all results into a single file
consolidate_results:
  stage: consolidate-results
  script:
    - touch ALL_PING_RESULTS.txt
    - for file in PING_RESULTS_*.txt; do
        cat $file >> ALL_PING_RESULTS.txt;
      done
  artifacts:
    paths:
      - ALL_PING_RESULTS.txt
  when: always
